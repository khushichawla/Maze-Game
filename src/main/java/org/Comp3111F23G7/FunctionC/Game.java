package org.Comp3111F23G7.FunctionC;

import org.Comp3111F23G7.FunctionA.MazeGUI;
import org.Comp3111F23G7.FunctionA.MazeGenerator;
import org.Comp3111F23G7.FunctionB.Searcher;
import org.Comp3111F23G7.Vertex;
import javax.swing.*;
import java.util.Scanner;

public class Game {
    /**
     * updateMaze function to check if the given indices are valid
     * @param maze - maze being used in the game
     * @param jerry - current position of jerry
     * @param oldJerry - old position of jerry
     * @param tom - current position of tom
     * @param oldTom - old position of tom
     */
    public static void updateMaze(int[][] maze, int[] jerry, int[] oldJerry, int[] tom, int[] oldTom) {
        int rowJ = jerry[0];
        int colJ = jerry[1];
        if(maze[rowJ][colJ] == 0 ){
            maze[rowJ][colJ]=6;
        }
        if(colJ == 1){
            maze[rowJ][colJ]=6;
        }
        if(oldJerry[0]!=-1 && oldJerry[1]!=-1){
            int rowOJ = oldJerry[0];
            int colOJ = oldJerry[1];
            maze[rowOJ][colOJ]=0;
        }
        int rowT = tom[0];
        int colT = tom[1];
        if(maze[rowT][colT] == 0 || maze[rowT][colT]==3){
            maze[rowT][colT]=8;
        }
        if(oldTom[0]!=-1 && oldTom[1]!=-1){
            int rowOT = oldTom[0];
            int colOT = oldTom[1];
            maze[rowOT][colOT]=0;
        }
    }
    /**
     * newPath function to generate a new path between tom and jerry
     * @param maze - maze being used in the game
     * @param jerry - current position of jerry
     * @param tom - current position of tom
     * @return the Vertex[] path generated
     */
    public static Vertex[] newPath(int[] jerry, int[] tom, int[][] maze){
        Searcher s =  new Searcher(maze);
        Vertex[] path = s.dijkstra(new Vertex(tom[1],tom[0]), new Vertex(jerry[1],jerry[0]));
        return path;
    }
    /**
     * playGame function to check if the given indices are valid
     * @param maze - maze being used in the game
     * @param jerry - current position of jerry
     * @param tom - current position of tom
     * @param mazeGenerator - the maze generated byt eh random maze generated
     */
    public static void playGame(int[][] maze, int[] jerry, int[] tom, MazeGenerator mazeGenerator) {
        int[] exit= {tom[0], tom[1]};
        Scanner scanner = new Scanner(System.in);
        Searcher s =  new Searcher(maze);
        int countV=0;
        Vertex[] path = s.dijkstra(new Vertex(tom[1],tom[0]), new Vertex(jerry[1],jerry[0]));
        int size = path.length-1;

        int[] oldJerry = new int[2];
        int[] oldTom = new int[2];

        while(true){
            System.out.println("Jerry's position is denoted by orange square and Tom's position is denoted by pink square ");
            System.out.print("Enter Jerry's next move (WASD), Press Q to exit the game: ");
            String input = scanner.nextLine();
            int[] jerryMove = calculateNextMove(jerry, input);
            if (jerryMove[0] == -1 && jerryMove[1] == -1) {
                System.out.println("Exiting the game...");
                break;
            } else if (isValidMove(jerryMove, maze)) {
                oldJerry[0]=jerry[0];
                oldJerry[1]=jerry[1];
                jerry[0] = jerryMove[0];
                jerry[1] = jerryMove[1];
                updateMaze(maze, jerry, oldJerry, tom, oldTom);
                for(int i=0; i<2; i++){
                    int y = path[countV].getX();
                    int x = path[countV].getY();
                    countV++;
                    if(countV == size ){
                        path=newPath(tom,jerry,maze);
                        size=path.length;
                        countV=0;
                        break;
                    }
                    oldTom[0] = tom[0];
                    oldTom[1] = tom[1];
                    tom[0] = x;
                    tom[1] = y;
                    updateMaze(maze, jerry, oldJerry, tom, oldTom);
                }
                updateMaze(maze, jerry, oldJerry, tom, oldTom);
            }
            else if (isValidMove(jerryMove, maze)==false){
                System.out.println("Invalid move! Try again.");
            }
            for(int i=0; i<30; i++){
                for(int j=0; j<30; j++){
                    mazeGenerator.maze[i][j] = (char) (maze[i][j] + '0');
                }
            }
            mazeGenerator.saveMazeToFile("maze.txt");
            int[][] nmaze = MazeGUI.loadMazeFromFile("maze.txt");
            SwingUtilities.invokeLater(() -> MazeGUI.createAndShowMazeGUI(nmaze));
            if(jerry[0]==exit[0] && jerry[1]==exit[1]){
                System.out.println("You won! :)");
                break;
            }
            if(jerry[0]==tom[0] && jerry[1]==tom[1]){
                System.out.println("You lost :(");
                break;
            }
        }
    }
    /**
     * calculateNextMove function to give the x,y coordinates depending on the WASD key entered
     * @param currentPos - the current position of the player
     * @param input - WASD key
     */
    public static int[] calculateNextMove(int[] currentPos, String input) {
        int[] nextMove = new int[2];
        switch (input.toLowerCase()) {
            case "q" -> {
                nextMove[0] = -1;
                nextMove[1] = -1;
            }
            case "w" -> {
                nextMove[0] = currentPos[0] - 1; // Move up
                nextMove[1] = currentPos[1];
            }
            case "a" -> {
                nextMove[0] = currentPos[0];
                nextMove[1] = currentPos[1] - 1; // Move left
            }
            case "s" -> {
                nextMove[0] = currentPos[0] + 1; // Move down
                nextMove[1] = currentPos[1];
            }
            case "d" -> {
                nextMove[0] = currentPos[0];
                nextMove[1] = currentPos[1] + 1; // Move right
            }
            default -> {
                nextMove[0] = currentPos[0]; // Stay in the same position
                nextMove[1] = currentPos[1];
            }
        }
        return nextMove;
    }
    /**
     * isValidMove function to check if the calculated position is correct
     * @param move - the calculated position of the player
     * @param maze - maze
     * @return True/False
     */
    public static boolean isValidMove(int[] move, int[][] maze) {
        if(move[0]==31 || move[1]==31 || move[0]==30 || move[1]==30){
            return false;
        }
        int row = move[0];
        int col = move[1];
        return (maze[row][col] == 0 || maze[row][col] == 8);
    }
}
